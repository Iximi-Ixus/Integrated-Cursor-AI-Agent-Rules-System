---
description: 
globs: 
alwaysApply: true
---
# 🎯 010-cursor_general_rules - Central Coordination Hub

## CUSTOMIZATION GUIDE 🔧
**Replace these placeholders to customize for your project:**
- `[PROJECT_NAME]` → Your actual project name
- `[PROJECT_COMMAND_QUALITY]` → Your quality check command (e.g., `npm test`, `make lint`, `python -m pytest`)
- `[PROJECT_COMMAND_TEST]` → Your test command
- `[PROJECT_COMMAND_BUILD]` → Your build command  
- `[PROJECT_COMMAND_LINT]` → Your linting command

**Technology Templates Available:**
- Python: `python docs/consistency_check.py`, `pytest`, `flake8`
- JavaScript/Node: `npm test`, `npm run lint`, `npm run build`
- TypeScript: `tsc --noEmit`, `npm run test`, `eslint`
- Go: `go test`, `go vet`, `golint`
- Rust: `cargo test`, `cargo clippy`, `cargo build`

## CRITICAL AGENT RULES - READ FIRST

⚠️ **MANDATORY GENERAL OPERATION RULES** ⚠️

1. **NO CONFIGURATION RULE MODIFICATIONS**: Agents MUST NOT modify cursor_*.mdc configuration rule files without explicit user approval
2. **WORKFLOW FILE PERMISSIONS**: Agents MAY modify @012-learned_memories and @020-task_list as part of normal workflow operations
3. **COORDINATION PROTECTION**: Never override domain-specific safety rules from this central coordination hub
4. **STRATEGIC ALIGNMENT**: Do not modify strategic vision or project objectives without user verification
5. **USER VERIFICATION REQUIRED**: All changes to configuration rules and strategic coordination require user approval

### Safe Workflow Operations (No Approval Required)
- Updating @012-learned_memories with new patterns, consolidation, timestamps
- Updating @020-task_list with status changes, implementation summaries, "Ready for Review" marking
- Reading all configuration rules for guidance and coordination
- Providing development guidance based on established rules

### Protected Configuration Operations (Require User Approval)
- Modifying any `cursor_*.mdc` configuration rule files
- Changing rule integration frameworks or coordination mechanisms
- Altering established workflow patterns or emergency protocols
- Overriding domain-specific safety constraints from central coordination

## Purpose

This rule provides **central coordination and integration framework** for all cursor rules, ensuring unified agent behavior and workflow management across [PROJECT_NAME].

## 🎯 Core Interaction Rules

**📋 Reference Priority**: Load @011-cursor_project_rules for project context and technical standards.

**🗂️ File Organization**: Apply @040-cursor_organization_rules for consistent file placement.

**⚡ Task Approach**: Use @013-cursor_riper_rules for systematic implementation (auto-scales by complexity).

**🌍 Environment**: Apply @021-cursor_environment_rules for DEV/TEST/STAGING/PROD configurations.

**✅ Quality Gates**: Trigger @032-cursor_quality_rules for dependencies, API changes, >100 lines, >5 files, new modules, user features.

**🧠 Memory**: Maintain patterns in @012-learned_memories using @031-cursor_memory_rules guidelines.

**🔀 Git Workflow**: Follow @022-cursor_git_rules for commits, branches, and deployment.

**📝 Task Management**: Update @020-task_list using @030-cursor_task_rules processes.

## 📂 Key Files & Commands

- **Task List**: @020-task_list
- **Quality Check**: `[PROJECT_COMMAND_QUALITY]`
- **Environment**: Auto-detect via branch/ENV_STAGE
- **Memory**: @012-learned_memories

**Example Commands by Technology:**
```bash
# Python Projects
python docs/consistency_check.py
pytest
python -m flake8

# JavaScript/Node Projects  
npm test
npm run lint
npm run build

# TypeScript Projects
tsc --noEmit
npm run test
eslint src/

# Go Projects
go test ./...
go vet ./...
golint ./...

# Rust Projects
cargo test
cargo clippy
cargo build
```

## 🚫 Agent Behavior Standards

- **Present changes**: One file at a time for user review
- **Skip apologies**: No apologetic language in responses
- **Avoid confirmations**: Don't seek approval for clear details
- **Preserve code**: Maintain unrelated structures unless explicitly required
- **Link real files**: Use actual project paths, not placeholders
- **Review context**: Check latest file contents before suggesting edits
- **Limit scope**: Respond only to explicit requests
- **Single edits**: Deliver all file changes in one cohesive block

## 🚨 Emergency Protocols

1. **Contradiction**: Task-specific rules override general rules
2. **Missing File**: Check `.cursor/rules/` directory first
3. **Task Confusion**: NEVER mark "Completed" - only "Ready for Review"
4. **Quality Failure**: Run `[PROJECT_COMMAND_QUALITY]` first
5. **Integration Issue**: Use centralized framework in Rule Integration section below

## ⚙️ Task Management Actions

### 🔄 Task Completion Workflow
```
Implementation Done → Status: "Ready for Review" + Summary
                   ↓
User: "mark completed" → Agent archives immediately
User edits file direct → Agent detects & offers archival  
User handles manual   → Agent respects user control
```

### 🔄 During Implementation
**Identify affected tasks** → **Update to "Ready for Review"** → **Add implementation summary** → **Review related tasks**

### 🔍 When Discovering Features
**Check "Not started" tasks** → **Update to "Ready for Review"** → **Add analysis summary** → **Ensure documentation reflects reality**

### 📈 Task List Accuracy
**Prioritize implemented features** → **Flag outdated descriptions** → **Suggest reorganization** when needed

## 🔧 Git Integration Actions

**Before commits**: Run `[PROJECT_COMMAND_QUALITY]`
**Commit messages**: Use conventional format based on changes
**Branch strategy**: Recommend names matching work type
**Documentation sync**: Include all updates before suggesting commits
**Testing**: Prompt for testing before main branch merge

## 📚 Documentation Consistency Actions

### 🚦 Quality Gate Triggers (Mandatory)
- **🔴 CRITICAL**: Dependencies changed, API changes, >100 lines, >5 files, new modules, user features
- **🟡 HIGH**: New [PROJECT_NAME] commands, security features, architectural changes, cross-module work  
- **🟢 MEDIUM**: 20-100 lines, 2-5 files, documentation updates, config changes, bug fixes
- **🔵 LOW**: <20 lines, single file, formatting, text updates, basic maintenance

### ✨ Before Code Changes
**Verify documentation accuracy** → **Plan required updates** → **Check quality gates**

### 🔄 During Implementation  
**Update help commands** → **Sync dependencies** → **Update API references** → **Maintain project structure docs**

### ⭐ After Implementation
**Update task status** → **Cross-check 2+ documents** → **Run quality commands** → **Prepare commit message**

## 📄 Documentation Process

1. **Check**: Quality gates + affected documents
2. **Note**: Required updates during work
3. **Update**: All affected documentation systematically  
4. **Validate**: Cross-check 2+ documents + run `[PROJECT_COMMAND_QUALITY]`
5. **Track**: Update task status with summaries
6. **Prepare**: Git commit message + branch strategy

## 🔥 Entropy Minimization

**Core Principle**: Reduce complexity while maintaining functionality.

### 🎪 Essential Actions
- **Update existing** rather than create duplicates
- **Maintain single source** of truth per information type
- **Document reality** not outdated plans
- **Consolidate** rather than scatter information
- **Integrate quality** during development
- **Reuse patterns** rather than reinvent

### 🔄 Implementation Flow
**Before**: Check existing solutions
**During**: Update docs with implementation  
**After**: Archive outdated info + update status

## 💻 Development Standards

### 🏗️ Code Quality
**Use descriptive names** → **Match project style** → **Optimize performance** → **Prioritize security** → **Add tests** → **Handle errors** → **Design modularly**

### 📱 Platform Requirements
**Ensure [MAIN_LANGUAGE] compatibility** → **Use named constants** → **Consider edge cases** → **Add assertions** → **Update in-app documentation**

### 🎪 Project Alignment
**Support local execution** → **Align with project objectives** → **Maintain documentation integrity** → **Follow Git best practices**

## 🔗 Rule Integration Framework

### 🗺️ Rule Hierarchy
**Foundation**: @010-cursor_general_rules, @011-cursor_project_rules
**Specialized**: @030-cursor_task_rules, @031-cursor_memory_rules, @022-cursor_git_rules, @032-cursor_quality_rules  
**Advanced**: @013-cursor_riper_rules, @021-cursor_environment_rules, @040-cursor_organization_rules

### 🔀 Workflow Integration
**Before**: Quality gates + environment detection + task review
**During**: Code standards + doc updates + memory recording
**After**: Task archival + quality validation + git prep

### 🔄 Central Auto-Trigger Keywords

**Quality Keywords** → `quality, test, lint, dependency, requirement, documentation, validate, check, deploy, security` → Load QA rules

**Task Keywords** → `task, implement, complete, status, feature, planning, work, progress, build, fix, add, create, update, develop, deploy, test, debug` → Load task rules + @020-task_list

**Memory Keywords** → `remember, learned, prefer, pattern, decision, strategic, approach, convention` → Load memory maintenance

**Git Keywords** → `git, commit, branch, merge, push, pull, checkout, repository, version, tag, release, deployment, workflow` → Load git workflow rules

**Environment Keywords** → `environment, deploy, deployment, staging, production, dev, test, config, configuration, branch, git, env, .env, build, release` → Load environment rules

**RIPER Keywords** → `research, innovate, plan, execute, review, implementation, complex, systematic, methodology` → Load RIPER protocol

**Project Keywords** → `[MAIN_LANGUAGE], [FRAMEWORK], [TECH_STACK], api, requirements, dependencies, code, implementation, module, standard, platform, error, logging, security, performance` → Load project rules

**Organization Keywords** → `file, directory, structure, organization, asset, documentation, naming, placement, location, path` → Load organization rules

## TECHNOLOGY STACK EXAMPLES 🛠️

### Python Projects
```yaml
Main Language: Python
Framework: Django/Flask/FastAPI
Quality Command: python docs/consistency_check.py  
Test Command: pytest
Lint Command: flake8
Auto-Trigger: python, django, flask, fastapi, pip, requirements.txt
```

### JavaScript/Node Projects
```yaml
Main Language: JavaScript
Framework: React/Express/Next.js
Quality Command: npm test
Test Command: npm run test:coverage
Lint Command: npm run lint
Auto-Trigger: javascript, node, npm, react, express, package.json
```

### TypeScript Projects
```yaml
Main Language: TypeScript
Framework: React/Angular/Vue
Quality Command: tsc --noEmit && npm test
Test Command: npm run test
Lint Command: eslint src/
Auto-Trigger: typescript, tsx, angular, vue, tsconfig.json
```

### Go Projects
```yaml
Main Language: Go
Framework: Gin/Echo/Fiber
Quality Command: go test ./... && go vet ./...
Test Command: go test -v ./...
Lint Command: golint ./...
Auto-Trigger: go, golang, gin, echo, fiber, go.mod
```

### Rust Projects
```yaml
Main Language: Rust
Framework: Actix/Warp/Rocket
Quality Command: cargo test && cargo clippy
Test Command: cargo test --verbose
Lint Command: cargo clippy -- -D warnings
Auto-Trigger: rust, cargo, actix, warp, rocket, Cargo.toml
```

### 🔄 Central Cross-Rule Integration Points

**Foundation Layer Integration**:
- **@010-cursor_general_rules ↔ @011-cursor_project_rules**: Central coordination provides framework while project rules define technical constraints
- **@011-cursor_project_rules → All Rules**: Technical standards and platform requirements inform all other rule applications
- **@010-cursor_general_rules → All Rules**: Behavior standards and workflow coordination guide all agent actions

**Task & Memory Integration**:
- **@030-cursor_task_rules ↔ @020-task_list**: Task management rules coordinate with active task tracking
- **@031-cursor_memory_rules ↔ @012-learned_memories**: Memory management rules coordinate with learned knowledge storage
- **@030-cursor_task_rules ↔ @090-completed_tasks**: Archival workflows maintain completed task history

**Development Workflow Integration**:
- **@022-cursor_git_rules ↔ @021-cursor_environment_rules**: Git branch strategy maps directly to environment detection
- **@032-cursor_quality_rules ↔ @011-cursor_project_rules**: Quality standards align with technical implementation requirements
- **@013-cursor_riper_rules → All Rules**: RIPER methodology integrates and coordinates all other rule applications

**Advanced Integration**:
- **@040-cursor_organization_rules ↔ @011-cursor_project_rules**: File organization standards align with module architecture
- **@021-cursor_environment_rules ↔ @022-cursor_git_rules**: Environment detection influences git workflow strategies
- **@032-cursor_quality_rules ↔ @013-cursor_riper_rules**: Quality gates integrate into RIPER Review phase validation

### 🎪 Central Integration Actions

**Task Management**: Real-time status updates + flexible archival + cross-reference validation + commit message integration

**Memory Management**: Progress-based consolidation + timestamp tracking + pattern documentation + strategic alignment validation + git workflow recording

**Quality Assurance**: Pre-implementation gates + documentation synchronization + strategic compliance + validation before archival

**Git Workflow**: Environment-aware strategies + pre-commit validation + branch-based detection + task completion references

**Environment Management**: Auto-detection influencing behavior + configuration adaptation + environment-specific standards + deployment considerations

**RIPER Protocol**: Auto-loading context files in Research → Documentation planning in Planning → Following standards in Execute → Quality validation in Review

**Project Standards**: Technical constraint validation + coding standard enforcement + platform compatibility verification + dependency management

**Organization Standards**: File placement validation + directory structure maintenance + asset organization + documentation consistency





