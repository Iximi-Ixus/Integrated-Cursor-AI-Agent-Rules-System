---
description: 
globs: 
alwaysApply: true
---
# üîÄ 022-cursor_git_rules - Git Workflow Rules

## CUSTOMIZATION GUIDE
**Purpose**: Template this file for your project by replacing placeholders with project-specific values
**Workflow Templates**: Examples provided for different project types and team sizes
**Branch Strategy**: Adapt branch naming and environment mapping to your project needs
**Placeholders to Replace**: [PROJECT_NAME], [MAIN_BRANCH], [DEV_BRANCH_PREFIX], [CONSISTENCY_CHECK_COMMAND]

## CRITICAL AGENT RULES - READ FIRST

‚ö†Ô∏è **MANDATORY GIT OPERATION RULES** ‚ö†Ô∏è

1. **NO UNAUTHORIZED COMMITS**: Agents MUST NOT commit changes without explicit user approval
2. **BRANCH PROTECTION**: Never merge to main/staging/prod without user verification
3. **DESTRUCTIVE OPERATION PREVENTION**: No force push, branch deletion, or history rewriting without explicit permission
4. **PRE-COMMIT VALIDATION**: Always run project validation before suggesting commits
5. **USER VERIFICATION REQUIRED**: All Git operations beyond basic status checks require user approval

### Safe Operations (No Approval Required)
- `git status` - Check repository status
- `git log` - View commit history  
- `git diff` - View changes (read-only)
- `git branch -a` - List branches (read-only)
- `git show` - Display commit information (read-only)

### Protected Operations (Require User Approval)
- All `git commit` operations
- All `git merge` operations  
- All `git push` operations
- All `git pull` operations
- All branch creation/deletion operations
- All `git add` operations
- All `git reset` operations
- All `git rebase` operations

## Purpose

This rule defines **Git workflow standards and safety constraints** for [PROJECT_NAME] while maintaining code quality, branch strategy, and deployment coordination across environments.

### Auto-Trigger Keywords
This rule is automatically loaded when agents detect: `git, commit, branch, merge, push, pull, checkout, repository, version, tag, release, deployment, workflow`

### Cross-Rule Integration Points
- **@010-cursor_general_rules**: Operates within centralized Rule Integration Framework for coordinated git workflow management
- **@021-cursor_environment_rules**: Git branch strategy maps directly to environment detection (dev/* ‚Üí DEV, main ‚Üí TEST, staging ‚Üí STAGING, prod ‚Üí PROD)
- **@011-cursor_project_rules**: Git operations must respect technical constraints and testing requirements
- **@032-cursor_quality_rules**: Pre-commit validation requires quality checks before all Git operations
- **@030-cursor_task_rules**: Task completion integrates with commit messages and branch strategies
- **@013-cursor_riper_rules**: Git workflow preparation integrated in RIPER Review phase

### Git Integration Actions
- **Before Commits**: Always run project validation and quality gates
- **During Operations**: Respect environment-specific branch strategies and safety constraints
- **Quality Integration**: Ensure all quality validations pass before suggesting Git operations
- **Task Coordination**: Update task statuses and prepare commit messages based on implementation progress
- **Environment Awareness**: Apply branch-based environment detection for workflow strategies

## WORKFLOW TEMPLATES

### Solo Developer Git Strategy
Simplified Git workflow optimized for single-developer productivity while maintaining code quality and project history.

### Team Collaboration Strategy
Enhanced Git workflow with feature branches, code reviews, and collaborative development practices.

### Enterprise Strategy
Advanced Git workflow with release branches, hotfix procedures, and comprehensive approval processes.

## Environment-Aware Branch Strategy

### Branch Structure and Environment Mapping
```
[MAIN_BRANCH] (TEST environment - stable feature testing)
‚îú‚îÄ‚îÄ [DEV_BRANCH_PREFIX]/feature-name (DEV environment - active development)
‚îú‚îÄ‚îÄ [DEV_BRANCH_PREFIX]/bugfix-description (DEV environment - bug fixes)
‚îú‚îÄ‚îÄ staging (STAGING environment - pre-production validation)
‚îî‚îÄ‚îÄ prod (PROD environment - production deployment)
```

**Branch Naming Convention Templates:**

**Development Branches:**
- **Feature Development**: `[DEV_BRANCH_PREFIX]/feature-name`, `[DEV_BRANCH_PREFIX]/add-user-auth`
- **Bug Fixes**: `[DEV_BRANCH_PREFIX]/bugfix-description`, `[DEV_BRANCH_PREFIX]/fix-login-error`
- **Experimental**: `[DEV_BRANCH_PREFIX]/experimental-feature`, `[DEV_BRANCH_PREFIX]/poc-new-api`

**Environment Branches:**
- **[MAIN_BRANCH]** (TEST environment - main development branch)
- **staging** (STAGING environment - pre-production testing)
- **prod/production** (PROD environment - production deployment)

**Special Purpose:**
- **hotfix/critical-issue** (Emergency fixes for production)
- **release/v1.x.x** (Release preparation branches)

### Environment Configuration Examples

**Web Application:**
```
project-root/
‚îú‚îÄ‚îÄ .env                    # Default/TEST environment ([MAIN_BRANCH] branch)
‚îú‚îÄ‚îÄ .env.dev               # Development environment config
‚îú‚îÄ‚îÄ .env.test              # Test environment config (same as .env)
‚îú‚îÄ‚îÄ .env.staging           # Staging environment config
‚îú‚îÄ‚îÄ .env.prod              # Production environment config
‚îú‚îÄ‚îÄ .env.example           # Template with all required variables
‚îî‚îÄ‚îÄ .gitignore             # Excludes all .env files except .env.example
```

**Configuration Management:**
```
config/
‚îú‚îÄ‚îÄ development.json
‚îú‚îÄ‚îÄ test.json
‚îú‚îÄ‚îÄ staging.json
‚îú‚îÄ‚îÄ production.json
‚îî‚îÄ‚îÄ default.json
```

### Environment Transition Workflows

‚ö†Ô∏è **CRITICAL**: These operations require explicit user approval. Agents must not execute these commands.

**DEV ‚Üí TEST ([MAIN_BRANCH] Branch):** *(USER EXECUTION ONLY)*
```bash
git checkout [MAIN_BRANCH]
git merge [DEV_BRANCH_PREFIX]/feature-name
# Environment automatically detects as TEST
```

**TEST ‚Üí STAGING ‚Üí PROD:** *(USER EXECUTION ONLY)*
```bash
# To staging
git checkout -b staging
git push origin staging

# To production
git checkout -b prod
git push origin prod
```

## Commit Message Convention

Use Conventional Commits format for clear history and automated tooling:

### Format and Types
```
<type>[optional scope]: <description>

[optional body]
[optional footer(s)]
```

**Standard Types**: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

### Technology-Specific Examples

**Web Application:**
```bash
feat(auth): add JWT authentication system
fix(api): resolve CORS issues in user endpoints
docs(readme): update API integration documentation
chore(deps): update react to v18.2.0
```

**Mobile Application:**
```bash
feat(ui): add dark mode toggle
fix(login): resolve biometric authentication on iOS
docs(setup): update development environment guide
test(auth): add unit tests for authentication flow
```

**Backend Service:**
```bash
feat(api): add user profile management endpoints
fix(db): resolve connection pool timeout issues
refactor(auth): improve JWT token validation
chore(deps): update express to v4.18.0
```

## Pre-Commit Workflow

Before every commit, ensure these steps are completed:

### Validation Steps Template
1. **Consistency Check**: `[CONSISTENCY_CHECK_COMMAND]`
2. **Quality Validation**: Run your project's quality suite
3. **Documentation Update**: Update related docs, task list, README, dependency files
4. **Staging and Commit**: `git add .` ‚Üí `git status` ‚Üí `git commit -m "type(scope): description"`

### Technology-Specific Pre-Commit Examples

**Python Projects:**
```bash
# Validation steps
python -m pytest tests/ || echo "No tests yet"
flake8 src/
black --check src/
mypy src/

# Git operations
git add .
git status
git commit -m "feat(module): implement new feature"
```

**Node.js Projects:**
```bash
# Validation steps
npm test
npm run lint
npm run type-check
npm audit

# Git operations
git add .
git status
git commit -m "feat(component): add user dashboard"
```

**Go Projects:**
```bash
# Validation steps
go test ./...
go vet ./...
golint ./...
go mod verify

# Git operations
git add .
git status
git commit -m "feat(service): implement user service"
```

## Feature Development Workflow Templates

### Basic Feature Development
```bash
# Start new work
git checkout -b [DEV_BRANCH_PREFIX]/new-feature-name

# During development - commit frequently
git add .
git commit -m "feat(module): implement initial functionality"
git commit -m "feat(module): add error handling"
git commit -m "docs(module): update documentation"

# Complete feature
[CONSISTENCY_CHECK_COMMAND]
git commit -m "feat(module): complete feature implementation

- Implemented core functionality
- Added error handling and logging  
- Updated documentation and task list
- All validation checks pass"

# Merge back to [MAIN_BRANCH]
git checkout [MAIN_BRANCH]
git merge [DEV_BRANCH_PREFIX]/new-feature-name
git branch -d [DEV_BRANCH_PREFIX]/new-feature-name
```

### Collaborative Feature Development
```bash
# Start new work
git checkout -b feature/user-authentication
git push -u origin feature/user-authentication

# Development with regular pushes
git add .
git commit -m "feat(auth): implement login endpoint"
git push origin feature/user-authentication

# Create pull request for review
# Merge via platform (GitHub, GitLab, etc.)
```

## Release and Deployment Strategy

### Versioning Strategy Templates

**Semantic Versioning (MAJOR.MINOR.PATCH):**
- **MAJOR**: Breaking changes, API changes
- **MINOR**: New features, backward compatible
- **PATCH**: Bug fixes, backward compatible

**Calendar Versioning (YYYY.MM.DD):**
- **Format**: 2024.03.15 (March 15, 2024)
- **Use Case**: Regular releases, time-based deployments

### Release Process Template
```bash
# Prepare release
git add .
git commit -m "chore: prepare release v1.2.0"

# Create release tag
git tag -a v1.2.0 -m "Release version 1.2.0

- [FEATURE_1_SUMMARY]
- [FEATURE_2_SUMMARY]
- [BUGFIX_SUMMARY]"

# Push to remote (when ready)
git push origin [MAIN_BRANCH]
git push origin v1.2.0
```

### Deployment Strategy Examples

**Continuous Deployment:**
```bash
# Automatic deployment on push to production branch
git push origin prod  # Triggers CI/CD pipeline
```

**Manual Deployment:**
```bash
# Manual deployment with verification
git checkout prod
git merge staging
[DEPLOYMENT_VALIDATION_COMMANDS]
git push origin prod
```

## Backup and Safety Practices

### Repository Safety
- Push to remote repository regularly: `git push origin [MAIN_BRANCH]`
- Push feature branches for backup: `git push origin [DEV_BRANCH_PREFIX]/current-work`
- Create tags for stable versions: `git tag v1.0.0`
- Use descriptive commit messages for easy history navigation
- Keep [MAIN_BRANCH] branch always in working state
- Test before merging to [MAIN_BRANCH]

### Recovery Procedures
```bash
# Undo last commit (keep changes)
git reset --soft HEAD~1

# Undo last commit (discard changes) - DANGEROUS
git reset --hard HEAD~1

# Restore specific file
git checkout HEAD -- [FILE_PATH]

# View reflog for recovery
git reflog
```

## Integration with Cursor Rules

**Centralized Integration Framework**: See @010-cursor_general_rules ‚Üí Rule Integration Reference for comprehensive integration coordination between all cursor rules.

## EXAMPLE CONFIGURATIONS

### Python Web Application
```bash
# Pre-commit validation
pytest tests/
flake8 app/
black --check app/
mypy app/

# Branch strategy
main (production)
‚îú‚îÄ‚îÄ dev/feature-api-v2
‚îú‚îÄ‚îÄ dev/fix-auth-bug
‚îî‚îÄ‚îÄ staging
```

### React/TypeScript Application
```bash
# Pre-commit validation
npm test -- --coverage
npm run lint
npm run type-check
npm run build

# Branch strategy
main (production)
‚îú‚îÄ‚îÄ feature/user-dashboard
‚îú‚îÄ‚îÄ feature/mobile-responsive
‚îî‚îÄ‚îÄ staging
```

### Microservices Project
```bash
# Pre-commit validation
docker-compose -f docker-compose.test.yml up --exit-code-from test
helm lint charts/
kubectl --dry-run=client apply -f k8s/

# Branch strategy
main (production)
‚îú‚îÄ‚îÄ feature/user-service-v2
‚îú‚îÄ‚îÄ feature/payment-integration
‚îú‚îÄ‚îÄ hotfix/critical-security-fix
‚îî‚îÄ‚îÄ staging
```
