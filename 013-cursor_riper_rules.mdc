---
description: 
globs: 
alwaysApply: true
---
# âš¡ 013-cursor_riper_rules - RIPER Protocol for Cursor Agents

## CUSTOMIZATION GUIDE ğŸ”§

**Essential Placeholders to Replace:**
- `[PROJECT_NAME]` â†’ Your project name
- `[PROJECT_COMMAND_QUALITY]` â†’ Your quality check command (e.g., `npm test`, `pytest`, `make lint`)
- `[PROJECT_MODULES]` â†’ Your main project modules (e.g., `auth, api, frontend`, `user, product, order`)
- `[MAIN_LANGUAGE]` â†’ Primary programming language
- `[TECH_STACK]` â†’ Your technology stack

**Template Integration Points:**
This file integrates seamlessly with all other cursor rules using the same @rule_name references. The RIPER methodology provides a universal framework that adapts to any project type or technology stack.

## CRITICAL AGENT RULES - READ FIRST

âš ï¸ **MANDATORY RIPER PROCESS RULES** âš ï¸

1. **NO UNAUTHORIZED COMPLEX OPERATIONS**: Agents MUST NOT initiate complex multi-file operations without explicit user approval
2. **PROCESS VALIDATION**: Always confirm RIPER phase requirements before proceeding with complex implementations
3. **SCOPE PROTECTION**: Do not automatically expand task scope beyond user-defined parameters
4. **SYSTEMATIC SAFETY**: Ensure Research phase includes safety validation before execution phases
5. **USER VERIFICATION REQUIRED**: All RIPER-driven complex operations require user approval before execution

### Safe Operations (No Approval Required)
- Providing RIPER methodology guidance and framework explanations
- Reading project context files for Research phase analysis
- Simple task planning and breakdown for straightforward implementations
- Context detection and complexity assessment
- Quality validation recommendations and suggestions

### Protected Operations (Require User Approval)
- Complex multi-file operations (>100 lines, >5 files, new modules, API changes)
- Automatic task scope expansion beyond user-defined parameters
- Execution phase initiation for complex tasks without explicit user verification
- Architectural changes or major refactoring through RIPER Execute phase
- Cross-module modifications through systematic RIPER implementation

## Purpose

This rule defines the **RIPER Protocol methodology** for systematic task execution with automatic complexity detection and safety validation, providing structured agent guidance across all development activities for [PROJECT_NAME].

### Auto-Trigger Keywords
This rule is automatically loaded when agents detect: `research, innovate, plan, execute, review, implementation, complex, systematic, methodology, riper, protocol, validation, context, loading, solution, breakdown, quality`

### Cross-Rule Integration Points
- **@010-cursor_general_rules**: Operates within centralized Rule Integration Framework as coordinating methodology
- **@011-cursor_project_rules**: Technical standards and coding requirements integrated in Execute phase validation
- **@030-cursor_task_rules**: Task status progression and archival workflows fully integrated across all phases
- **@031-cursor_memory_rules**: Pattern recording and entropy minimization workflows integrated during implementation
- **@022-cursor_git_rules**: Git workflow requirements and safety constraints fully integrated in Review phase
- **@032-cursor_quality_rules**: Quality gate triggers and validation requirements integrated throughout all phases
- **@021-cursor_environment_rules**: Environment detection and configuration safety integrated in Research phase
- **@040-cursor_organization_rules**: File placement and organization standards integrated in Planning phase

### Integration Actions
- **Research Phase**: Auto-load @011-cursor_project_rules, @012-learned_memories, @020-task_list, and @021-cursor_environment_rules for comprehensive context
- **Planning Phase**: Apply @040-cursor_organization_rules for file placement and @030-cursor_task_rules for task management strategy
- **Execute Phase**: Follow @011-cursor_project_rules coding standards and @010-cursor_general_rules presentation standards
- **Review Phase**: Trigger @032-cursor_quality_rules validation and prepare @022-cursor_git_rules workflow actions
- **Memory Integration**: Record successful patterns in @012-learned_memories and update task statuses in @020-task_list throughout process

## Overview

The RIPER Protocol provides a structured methodology for agents to approach tasks systematically. RIPER automatically adapts to task complexity using objective criteria.

**RIPER Framework:**
- **R** - Research (context detection and safety validation)
- **I** - Innovate (solution selection)
- **P** - Plan (implementation strategy)
- **E** - Execute (implementation)
- **R** - Review (quality validation)

## Automatic Complexity Detection

RIPER automatically scales based on objective task characteristics:

### Complexity Triggers
- **ğŸ”´ Complex**: >100 lines, >5 files, new modules, API changes, architectural changes
- **ğŸŸ¡ Medium**: 20-100 lines, 2-5 files, documentation updates, feature enhancements  
- **ğŸŸ¢ Simple**: <20 lines, single file, formatting, minor text updates

### Phase Scaling
- **Complex Tasks**: Full R-I-P-E-R with detailed outputs and safety validation
- **Medium Tasks**: Streamlined R-P-E-R (skip Innovation for known solutions)
- **Simple Tasks**: Minimal P-E-R (context auto-detected, planning minimal)

## RIPER Phase Actions

### Research (R) - Context Loading and Safety Validation
**Mandatory Context Loading (All Tasks):**
- @011-cursor_project_rules - Technical constraints, coding standards, platform requirements
- @012-learned_memories - Historical decisions, user preferences, strategic context
- @020-task_list - Current status, dependencies, related active tasks
- Existing codebase patterns and established conventions

**Safety Validation (Complex Tasks):**
- Verify user approval for operations requiring protected permissions
- Check environment constraints via @021-cursor_environment_rules
- Validate quality gate triggers per @032-cursor_quality_rules
- Confirm Git workflow readiness per @022-cursor_git_rules

**Outputs**: Context summary, constraint identification, impact assessment, safety clearance status

### Innovate (I) - Solution Selection (Complex Tasks Only)
**Solution Generation:**
- Generate 2-3 alternative approaches for complex implementations
- Evaluate against project constraints from loaded context
- Consider integration points with existing modules ([PROJECT_MODULES])
- Assess resource requirements and timeline implications

**Decision Documentation:**
- Document selected approach with rationale
- Note trade-offs and potential risks
- Identify fallback options if primary approach fails

**Outputs**: Selected solution approach, documented alternatives, risk assessment

### Plan (P) - Implementation Strategy
**Implementation Breakdown:**
- Break down into specific, actionable steps with clear sequence
- Identify ALL affected files with explicit file paths
- Plan documentation updates following @040-cursor_organization_rules
- Map task dependencies and update requirements

**Cross-Rule Integration Planning:**
- Quality gates: Plan when to trigger @032-cursor_quality_rules validation
- Task management: Plan status updates per @030-cursor_task_rules workflows
- Memory updates: Plan @012-learned_memories updates for patterns and decisions
- Git strategy: Plan commit sequence per @022-cursor_git_rules workflows

**Outputs**: Step-by-step implementation sequence, complete file manifest, documentation update plan, integration checklist

### Execute (E) - Systematic Implementation
**Code Implementation Standards:**
- Follow ALL coding standards from @011-cursor_project_rules
- Implement one file at a time per @010-cursor_general_rules presentation standards
- Maintain consistency with existing module patterns
- Include comprehensive error handling and logging

**Documentation Synchronization:**
- Update user-facing documentation systematically during implementation
- Maintain dependency files accuracy with actual imports
- Update in-app help and command documentation
- Ensure environment variable documentation consistency

**Progress Tracking:**
- Update task status to "Ready for Review" when implementation complete (NEVER "Completed")
- Record implementation patterns in @012-learned_memories for future reference
- Document any deviations from plan with rationale

**Outputs**: Code changes, documentation updates, test coverage validation, task status updates

### Review (R) - Comprehensive Quality Validation
**Quality Checks:**
- Run `[PROJECT_COMMAND_QUALITY]` if available
- Execute relevant quality tools per @032-cursor_quality_rules
- Validate cross-document consistency (minimum 2 related documents)
- Verify implementation matches planned approach

**Task and Documentation Validation:**
- Update @020-task_list with "Ready for Review" status and comprehensive summary
- Cross-reference related tasks for accuracy and status updates
- Ensure all affected documentation reflects actual implementation
- Validate user-facing features include proper help integration

**Git Workflow Preparation:**
- Prepare conventional commit message per @022-cursor_git_rules
- Verify pre-commit requirements satisfied
- Document any environment-specific considerations
- Plan branch strategy if applicable

**Outputs**: Quality validation results, task status updates, commit message, next steps recommendation

## Agent Implementation Guidelines

### Automatic RIPER Activation
**Task Detection:**
- Agent receives implementation request from user
- Complexity automatically assessed using objective criteria (lines, files, modules)
- Appropriate RIPER phase sequence selected based on complexity level
- No user configuration required - operates transparently

**Context Loading:**
- ALWAYS load mandatory context files in Research phase before proceeding
- Read complete files, not partial sections, to ensure full context understanding
- Cache context for conversation duration to avoid repeated loading
- Report any missing or inaccessible context files to user

### Cross-Rule Integration Requirements

**Quality Assurance Integration:**
- Trigger @032-cursor_quality_rules validation for all MANDATORY quality gates
- Run quality checks BEFORE suggesting fixes or modifications
- Never modify working code for quality improvements without user approval
- Include quality validation in Review phase for ALL complex tasks

**Task Management Integration:**
- Update @020-task_list status progression: Not started â†’ In progress â†’ Ready for Review
- NEVER mark tasks as "Completed" - only user can do this per @030-cursor_task_rules
- Add comprehensive implementation summaries when marking "Ready for Review"
- Cross-reference and update related tasks during implementation

**Memory Management Integration:**
- Record successful implementation patterns in @012-learned_memories
- Document architectural decisions and their rationale
- Update user preferences and workflow patterns discovered
- Consolidate duplicate information per @031-cursor_memory_rules entropy minimization

**Git Workflow Integration:**
- Follow @022-cursor_git_rules for ALL Git operations - require user approval for commits
- Prepare conventional commit messages in Review phase
- Run `[PROJECT_COMMAND_QUALITY]` before suggesting commits
- Plan branch strategy based on change complexity and environment

**Environment Management Integration:**
- Auto-detect current environment via @021-cursor_environment_rules
- Adapt implementation approach to detected environment (DEV/TEST/STAGING/PROD)
- Never modify production configurations without explicit user approval
- Include environment-specific considerations in planning

### Agent Behavior Standards

**Communication:**
- State which RIPER phase is currently active
- Report context loading results and any constraints discovered
- Clearly distinguish between Safe Operations and Protected Operations
- Request user approval explicitly for all protected operations

**Error Handling:**
- If context loading fails, report specific files and continue with available context
- If quality checks fail, report issues before proceeding
- If user approval required, pause and request permission explicitly
- Document all deviations from planned approach with rationale

**Progress Transparency:**
- Report completion of each RIPER phase with explicit outputs
- Update task status in real-time during implementation
- Inform user when ready for Review phase quality validation
- Prepare next steps recommendations with clear action items

### Integration Validation Checklist

**Before Execute Phase (Complex Tasks):**
- [ ] All mandatory context loaded successfully
- [ ] Safety validation completed for protected operations
- [ ] User approval confirmed for complex multi-file operations
- [ ] Quality gates identified and validation planned
- [ ] Environment constraints verified

**During Execute Phase:**
- [ ] One file at a time presentation per @010-cursor_general_rules
- [ ] ALL coding standards followed per @011-cursor_project_rules
- [ ] Documentation updated systematically during implementation
- [ ] Task status updated to "In progress" then "Ready for Review"

**Review Phase Completion:**
- [ ] Quality validation executed successfully
- [ ] Cross-document consistency verified (minimum 2 files)
- [ ] Task summary comprehensive and technically accurate
- [ ] Commit message prepared per Git workflow standards
- [ ] Next steps clearly defined with user action items

## Technology Stack Examples ğŸ› ï¸

### Python Projects Integration
```yaml
PROJECT_COMMAND_QUALITY: "python docs/consistency_check.py"
PROJECT_MODULES: "api, models, utils, tests"
Quality Tools: "pytest, flake8, mypy, black"
Common Tasks: "API endpoints, data models, utility functions"
```

### JavaScript/Node Projects Integration
```yaml
PROJECT_COMMAND_QUALITY: "npm test && npm run lint"
PROJECT_MODULES: "components, pages, api, utils"
Quality Tools: "jest, eslint, prettier, typescript"
Common Tasks: "React components, API routes, utility functions"
```

### Go Projects Integration
```yaml
PROJECT_COMMAND_QUALITY: "go test ./... && go vet ./..."
PROJECT_MODULES: "cmd, internal, pkg, api"
Quality Tools: "go test, go vet, golint, gofmt"
Common Tasks: "HTTP handlers, service logic, data models"
```

### Full-Stack Projects Integration
```yaml
PROJECT_COMMAND_QUALITY: "npm run test:full && npm run lint:all"
PROJECT_MODULES: "frontend, backend, shared, database"
Quality Tools: "Multi-language toolchain integration"
Common Tasks: "End-to-end features, API integration, database migrations"
```

## Compatibility with All Rule Files

### Foundation Rules Compatibility
- **@010-cursor_general_rules**: Full integration via centralized Rule Integration Framework
- **@011-cursor_project_rules**: Technical standards and coding requirements integrated in Execute phase

### Specialized Rules Compatibility
- **@030-cursor_task_rules**: Task status progression and archival workflows fully integrated
- **@031-cursor_memory_rules**: Pattern recording and entropy minimization workflows integrated
- **@022-cursor_git_rules**: Git workflow requirements and safety constraints fully integrated
- **@032-cursor_quality_rules**: Quality gate triggers and validation requirements integrated

### Advanced Rules Compatibility
- **@021-cursor_environment_rules**: Environment detection and configuration safety integrated
- **@040-cursor_organization_rules**: File placement and organization standards integrated

### Workflow Files Integration
- **@012-learned_memories**: Pattern recording, decision documentation, user preference updates
- **@020-task_list**: Status updates, implementation summaries, cross-task relationships

**Integration Verification**: RIPER protocol successfully integrates with all 12 rule and workflow files without conflicts or ambiguities.

## ğŸ¯ CUSTOMIZATION EXAMPLES

### Example 1: React TypeScript Web App
```yaml
PROJECT_NAME: "EcommerceApp"
PROJECT_COMMAND_QUALITY: "npm test && tsc --noEmit"
PROJECT_MODULES: "components, pages, store, api"
MAIN_LANGUAGE: "TypeScript"
TECH_STACK: "React, Redux, Node.js"
```

### Example 2: Python FastAPI Microservice
```yaml
PROJECT_NAME: "UserServiceAPI"
PROJECT_COMMAND_QUALITY: "pytest && flake8"
PROJECT_MODULES: "api, models, services, utils"
MAIN_LANGUAGE: "Python"
TECH_STACK: "FastAPI, PostgreSQL, Redis"
```

### Example 3: Go Microservices Platform
```yaml
PROJECT_NAME: "PaymentService"
PROJECT_COMMAND_QUALITY: "go test ./... && go vet ./..."
PROJECT_MODULES: "cmd, internal, pkg, proto"
MAIN_LANGUAGE: "Go"
TECH_STACK: "Gin, gRPC, PostgreSQL"
```

**Note**: RIPER methodology is completely technology-agnostic and adapts to any project structure or development workflow while maintaining all safety and integration features.

